### 사전지식
MSS(Maximum Segment Size) : TCP 세그먼트로 보낼 수 있는 최대 크기. 전송 계층으로부터 캡슐화된 데이터는 헤더까지 포함한 값이 MTU이다. 하지만 MSS는 헤더크기를 산정하지 않고 페이로드 크기만 따진다.
#### TCP 프로토콜
연결을 지향하기 때문에 UDP보다는 안정적인 통신을 제공한다. 데이터를 안정적으로 순서대로 에러없이 전달 할 수 있게 해준다. 일반적으로 통신할 경우 TCP IPv4 Ethernet 프로토콜 3가지를 사용한다. TCP는 안전하게 전달할려고 여러 기능을 사용하기때문에 UDP보다 조금 느리지만 체감
#### TCP 프로토콜의 구조

|             |                           |                                       |                      |     |
| ----------- | ------------------------- | ------------------------------------- | -------------------- | --- |
| Byte Offset | 0                         | 1                                     | 2                    | 3   |
| 0           | **Source Port**           | -                                     | **Destination Port** | -   |
| 4           | **Sequence Number**       | -                                     | -                    | -   |
| 8           | **Acknowledgment Number** | -                                     | -                    | -   |
| 12          | Offset/Reserved           | **TCP Flags** C E U **A** P R **S F** | **Window**           | -   |
| 16          | Checksum                  | -                                     | Urgent Pointer       | -   |
| 20          | TCP Options ~             | (variable length,optional)            | -                    | -   |
**출발지 포트, 목적지 포트** : 어플리케이션 프로세스를 식별 할 수 있는고유 번호
**순서 번호** : 송수신되는 세그먼트 데이터 첫 바이트에 부여되는 번호
**확인 응답 번호** :순서 번호에 대한 응답 (다음으로 수신받길 기대하는 바이트 번호)
**Offset**은 header의 길이.(똑같이 4로 나눔).
**Reserved** 예약된필드. 사용하지 않음.
**Window** 한 번에 수신받고자 하는 양. 내 남아있는 TCP 버퍼를 알려주는 것
**TCP Options** 은 IP프로토콜 Option처럼 잘 안 붙고 붙어도 4바이트씩 붙는다 (총 10개까지. 일반적으로 20바이트지만 60바이트까지 늘어날 수 있음)

제어비트(TCP 플래그) : U A P R S F 만 알면 된다. TCP는 통신하면서 상대방이랑 연결상태를 물어보는데 그 때 나타내는 값이다. 어떤 플래그를 세팅해서 보내는지에 따라서 물어보는건지, 데이터 보내도 되는지 대답, 연결종료인지, 연결 초기화인지, 데이터를 보내는건지, 급한데이턴지 등등 지정하는 값이 플래그이다.

#### 제어비트 TCP 플래그 종류
Urgent flag : 우선순위가 높은 데이터가 포함되어있다. U가 1이면 급한 데이터다. Urgent Pointer랑 세트이다.
**Ack flag** : 승인비트. 데이터 보내도 되는지 물어보는 것에 대해 응답해주는 플래그. 
Push flag : 밀어넣기비트. TCP버퍼가 일정 크기만큼 쌓여야 전송하는데 이거랑 상관없이 계속해서 데이터를 밀어넣겠다는 flag
**Reset flag** : 초기화 비트. 상대방과 연결되어있는 상태에서 데이터를 주고받을 때 문제가 발생하여 reset하자는 flag
**Sync flag** : 동기화비트.  상대방이랑 연결을 시작 할 때 무조건 사용하는 flag. Sync flag가 처음 보내진 후 부터 둘 사이의 연결이 동기화 됨
**Fin flag** : 종료비트. 연결을 끊을 때 사용하는 flag.
##### 플래그의 생김새 
.... ..0. .... U
.... ...0 .... A
.... .... 0... O
.... .... .0.. R
S
F

### 순서 번호
어플리케이션으로부터 1900 바이트를 전송계층이 받았다. 500바이트씩 끊어서 보내면 세그먼트 A,B,C,D에 500,500,500,400 바이트씩 받는다. 그러면 이제 세그먼트에 초기 순서번호를 랜덤하게 받는다(100 같이.) 다음 순서번호는 그럼 600, 1100, 1600이 된다.
### 확인 응답 번호
순서번호가 8000번인 세그먼트를 받았다면 다음으로 응답받길 원하는 응답번호를 준다.(8001) 그럼 응답 번호를 받은 호스트는 다음 응답번호를 보낸다.
#### TCP를 이용한 통신과정
**연결 수립 과정** : 둘 사이의 연결을 수립하는 과정이 중요. TCP를 이용한 통신을 할 때 프로세스와 프로세스를 연결하기 위해 가장 먼저 수행되는 과정
1. 클라이언트가 서버에게 요청 패킷을 보냄. 서버가 클라이언트에 보내는경우는 거의 없다.
2. 서버가 클라이언트의 요청을 받아들이는 패킷을 보내고
3. 클라이언트는 이를 최종적으로 수락하는 패킷을 보낸다.
- 위의 3개의 과정을 3Way Handshake라고 부른다.

ex) 3Way Handshake의 예제
1. 클라이언트가 Eth|IPv4|TCP 패킷을 만들어서  웹 서버에 보낸다. 
	(Flag : SYN SEQ : 100, ACK : 0)
2. 서버가 요청을 받았으면 디캡슐화하여 내용을 확인한다.
3. 요청 왔다는걸 확인하고 답장하는 패킷을 만들어서 보낸다 
	(Flag : SYN+ACK S : 2000 A:101)
4. 클라이언트는 Sync와 Ack를 보고 요청을 수락하는 패킷을 보낸다 
	(Flag : ACK S:101 A:2001)

2-A 번호는 답장을 줄 때 받은 S 번호 +1를 한다. (101)
2-S 번호는 처음 보낼 때 자기만의 랜덤한 값을 생성한다. (2000)
3-A 번호는 받은 S번호 +1 한다. (2001)
3-S 번호는 답장을 보내는 것이므로 동기화가 되어 받은 A 번호가 된다 (101)

이렇게 수락이 되면 클라이언트가 먼저 요청을 보낸다.

**연결 수립 후 데이터 주고받는 과정** : 연결이 수립된 상태에서 데이터를 주고받을 때 SEQ, ACK번호를 이어가기 때문에 맨 마지막 클라이언트가 서버에게 패킷을 보내고 끝났는데 이 상태에서 클라이언트가 다시 데이터를 서버에게 보낸다.
1. 보낸 쪽에서 또 보낼 때는 SEQ번호와 ACK번호가 그대로다.
2. 받는 쪽에서 SEQ번호는 받은 ACK번호가 된다.
3. 받는 쪽에서 ACK번호는 받은 SEQ번호 + 데이터의 크기가 된다 (1이 아니다. 연결 수립 때는 데이터 페이로드가 없어서 1이였다)

ex) 
1. 캡슐화하여 데이터(100)를 담고 보낸다. 
	(Flag : PSH+ACK S:101 A:2001)
2. 서버가 클라이언트의 데이터를 받고 답장 패킷(500)을 보낸다 (ex: ㅁㅁ을 보내줘)
	(Flag : PSH+ACK S:2001 A:201)
3. 최종적으로 잘 받았다고 답장 패킷을 보낸다.
	(Flag : ACK S:201 A:2501)
#### 자세히 - 연결
1. 호스트A가 호스트B와 통신을 시작 할려고하면 A가 B에게 SYN 세그먼트(SYN 비트가 1로 되어있음)를 보낸다. 
2. B가 수락할 의사가 있다면 SYN과 ACK비트가 1로된 세그먼트(SYN+ACK)를 A에게 보내고 이 과정에서 확인 응답 번호와 함께 자신의 순서번호도 알려준다. 
3. 제 연결을 시작하겠다고 ACK 세그먼트를 보낸다(B가 보내준 순서번호에 대한 응답번호를 보냄)
- 여기서 엑티브 오픈 호스트, 패시브 오픈 호스트는 B이다.
#### 자세히 - 종료
1. A가 B에게 FIN 세그먼트를 보낸다.
2. B가 A에게 ACK를 보내고 FIN을 보낸다.
3. A가 ACK를 보내고 시간이 지나면 연결을 끊고 B는 ACK는 A가 보낸 ACK를 받으면 바로 연결을 끊는다
 - 여기서 A는 액티브 클로즈 호스트 B는 패시브 클로즈 호스트이다.

#### TCP 상태전이도
데이터를 주고받으면서 **TCP의 연결 상태가 변화**한다. (TCP는 상태 값이 있기 떄문에 stateful 프로토콜이다)
CLOSED : 포트가 닫혀있는 상태 ( 클라 : active open 서버 : passive open  )
클라이언트가 포트를 능동적으로 열면서 SYN 패킷을 보내고 SYN_SENT 상태가 된다.
**LISTEN** : 4계층은 포트번호를 사용하고 프로그램이 실행중이면 특정 포트번호를 열어놓고 사용한다. 언제든지 연결 요청을 받을 수 있는 상태이며 SYN 세그먼트를 기다리는 상태이다. SYN 세그먼트를 받으면 3way-handshake가 실행된다. 
SYN_SENT : SYN 세그먼트를 보낸뒤에  SYN+ACK 세그먼트를 기다리는 상태
SYN_RCVD : SYN,ACK 세그먼트를 보내고 그에 대한 ACK를 대기하는 상태
**ESTABLISHED** : 연결이 서로 수립이 된 상태. 서버를 실행시켰으면 해당 서버의 포트번호가 LISTEN 상태인지 확인. 그 다음 클라이언트와 서로 연결을 하게 되면 이 상태가 된다. 그럼 통신 가능 상태가 됨. 언제든 데이터 교환이 가능한 상태이다.
**FIN-WAIT-1, FIN-WAIT-2, CLOSE, CLOSING, LAST-ACK, TIME_WAIT** : 연결 해제시 사용되는 상태
1. EST상태 일 때 FIN 세그먼트를 보내면 FIN-WAIT-1 상태가 된다. 
2. 상대방은 ACK 세그먼트를 FIN 세그먼트를 보내기 전까지 CLOSE-WAIT가 된다. 
3. 다시 FIN을 보냈던 세그먼트가 ACK세그먼트를 받고 FIN 세그먼트를 받기 전까지 FIN-WAIT-2이고 그 상태로 FIN 세그먼트를 받고 ACK 세그먼트를 보내면 TIME-WAIT 상태가 된다. 
4. 상대는 마지막 FIN 세그먼트를 보내고 마지막 ACK 세그먼트를 받기 전까지 LAST-ACK라고 하고 ACK까지 받으면 CLOSEE가 된다
5. CLOSING은 FIN세그먼트에 대해 ACK를 보냈지만 자신의 FIN 세그먼트에 대한 ACK 세그먼트를 받지 못한 상태. (마지막 ACK 세그먼트를 보냈으면 유실을 대비하여 바로 끊지 않는다. 패킷 혼선 방지)

### TCP 재전송 기능
TCP는 신뢰성 프로토콜
- 무엇인가를 확실히 전송했따는 보장이 있으려면?
	- 재전송 기반의 오류 제어 : 잘못 전송된 경우 재전송
	- 흐름 제어 : 받을 수 있을 만큼만 받기
	- 혼잡 제어 : 보낼 수 있는 상황에서만 보내기
##### TCP는 언제 잘못 되었음을 인지할까? 
1. 중복된 ACK 세그먼트를 수신했을 때
2. 타임아웃이 발생했을 때 (재전송 타이머로 운영체제가 관리. 뭔가를 보낼 때 타이머를 스타트 시키고 타이머가 일정시간 지나면 timeout이 발생한다.)
###### - 올바른 통신 
A: n번 세그먼트 받아
B: 잘 받았어. n+1 세그먼트 보내줘
A: 응 n+1 받아 (반복)

(1번의 경우)여기서 A가 중간에 소실이 된다면 B가 중복된 세그먼트를 보내달라고 ACK를 보내고 A는 이걸 통하여 유실 됐다는 것을 알 수 있다.

(2번의 경우)타임아웃이 발생한 경우는 n+1번의 세그먼트를 보내는데 Timeout이 발생하면  n+1 세그먼트를 다시 재전송한다.

- TCP는 재전송 기반의 오류 제어 수행
- 재전송을 기반으로 잘못된 전송을 바로잡는 것 : ARQ(자동 재전송 요구)
- ARQ는 3가지가 있는데 Stop-and-Wait ARQ, Go-Back-N ARQ, Selective Repeat ARQ 3개가 있다.
#### Stop-and-Wait ARQ
- 가장 단순한 형태
- 제대로 보냈음을 확인하기 전까지는 보내지 않음
- 전송하고, 확인하고, 전송하고, 확인하고.... 
- 네트워크 이용 효율이 낮아지는 문제가 있다.
#### Go-Back, Selective Repeat ARQ
- 파이프라이닝 기법을 사용하여 해결한다. 동시에 명령어를 사용한다. N,N+1,N+2를 순서대로 보내는게 아니라 모두 한번에 보내고 한번에 받는다.
- Go-Back은 중간에 손실되어 올바르지 않는 세그먼트가 수신되면 모든 세그먼트 폐기. (자연스럽게 timeout이 적용됐을 때)
- Go-Back은 **누적 확인 응답**. 하나에서 문제가 있으면 그 뒤에 것들을 폐기한다. 그래서 여기에서의 **확인 응답**은 지금까지 얼마나 세그먼트를 받았느냐이다.
- Selective Repeat ARQ는 개별 확인 응답. Go-Back에 비해서 보내는쪽이 알아서 찾아서 다시 손실된 데이터를 보내서 할 게 좀 더 많다.

- 빠른 재전송 기법 : 같은 세그먼트를 여러본 보낸다. 중복된 세그먼트를 이용하여 3번의 중복 세그먼트를 수신하면  재전송을 요구하기 하여 타임아웃이 일어나기전에 미리 처리 할 수 있음

#### TCP/IP 연결에서 3way handshake 후
연결 후 파일을 다운로드 받으면 
##### Web 서버 상황
Server(프로세스)쪽에서는 소켓(파일)에 대고 RW(I/O)를 할 수 있는데 R하고 W를 각각 다른말로 부른다. R : Receive, W : Send. 그니까 서버 프로세스는 소켓에 대고 IO를 한다. HDD같은 메모리 장치 안에 File이 들어있다. A.bmp이 있을 때 파일 시스템에 의해 관리가 되어 데이터를 주거니 받거니 한다. 뭘 하든 서버에 메모리를 할당하게 되어있다. 파일이 1.4MB 일 때 메모리의 크기는 보통 1.4MB보다 작다. 메모리 사이즈가 64KB 일 때 64KB씩 끊어서 1.4MB를 읽어온다. 그럼 파일을 64KB씩 메모리에 끌어올려서 Read를 먼저 한 것이다. 그럼 이 프로세스는 소켓으로 TCP에 맞닿은 지점에 분해가 일어난다. 이 지점에서도 버퍼가 있다. 메모리의 버퍼를 1번, TCP의 버퍼가 2번 일 때,  버퍼1번의 메모리 64KB가 버퍼2번으로 카피가 된다.(Buffered I/O). TCP가 IP쪽으로 넘어 갈 때 Segment로 자른다. 직소퍼즐을 떠올리면 된다. 직소퍼즐 4개가 64KB면 버퍼1의 직소퍼즐 4개가 똑같이 복사돼서 버퍼2번에 저장된다. 이렇게 분해가 일어날 때 앞에 번호를 붙인다.  패킷이 택배박스라고 할 때 택배박스 안에 직소퍼즐 1번을 담는다. 패킷이 담기면 택배기사한테 맡겨서 NIC를 지나면 트럭(Frame)을 타고 인터넷을 통해 Client로 간다. 패킷은 논리적으로 end-point끝에서 끝으로 가지만 그게 frame화 돼서 갈 때는 frame이 생겼다 사라졌다한다. Client에 가는동안 트럭이 여러번 바껴서 간다.


![](https://i.imgur.com/VALrJr6.jpg)
##### Web 클라이언트 상황
PC 쪽에서도 NIC가 있고 서버랑 구조가 똑같다. 서버쪽에서도 버퍼가 있듯이 클라이언트 파일에도 버퍼가 있다. TCP도 똑같이 버퍼를 가지고 있다.
트럭(frame)이 왔을 때 트럭에서 택배를 꺼낼 때 IP를 만나면 박스가 뜯겨서 직소퍼즐(세그먼트)가 나온다. IP 수준에서 패킷의 분해가 일어나고 TCP단에서 세그먼트가 나온다. 나온 세그먼트는 TCP 버퍼에 저장이 된다. 이렇게 하나씩 오면서 버퍼에 세그먼트를 붙이는데 보통 세그먼트가 2개정도가 오면 잘 수신했다고 서버에 ACK에 번호를 붙여 보낸다. 서버 단에서는 2개정도를 보내고 기다리고 ACK를 받으면 그 때 3번을 보낸다. 이 때 wait를 하면서 속도지연이 발생하다 (TCP가 UDP보다 느린 이유). 클라이언트 단에서는 세그먼트를 2개까지 받았을 때 여유가 있다. 이 공간을 window size라고 말한다. (수신측에서 세그먼트가 날라왔을 때 조립해서 넣을 수 있는 공간). 그래서 ACK 3번을 보낼 때 window size도 같이 적어서 보낸다. 서버단에서 ACK를 받아서 3번을 보낼때 window size를 보고 세그먼트를 보낼 여유공간이 없으면 보내지 않는다. 전송을 할 때 수신측의 window size > mss(maximum segment size)면 보낸다. 크지 않으면 보내지 않고 wait가 걸린다. TCP에는 세그먼트들이 계속 쌓이는데 TCP 버퍼의 있는 세그먼트를 File I/O Buffer로 보내야한다. 프로세스 입장에서도 소켓에 대해 RW를 하는데 Receive의 속돌들 따져야한다. TCP Buffer에서 File I/O Buffer로 올리는 Read 속도가 Network 수신 속도 (세그먼트를 TCP Buffer로 옮기는 속도)보다 빨라야한다. Network 수신속도가 빨라지면 TCP Buffer의 공간이 점점 좁아져서 여유가 사라진다. 그렇게되면 서버에서 데이터를 보낼 때 여유공간이 없어서 보낼 수 없다. window size를 잘 체크하면 네트워크에서 어플리케이션의 문제를 파악 할 수 있다. (Read 속도가 너무 느려서 TCP Buffer의 공간이 계속 줄어들면 문제를 프로그램에서 찾아야한다.)



![](https://i.imgur.com/D22mPfb.jpg)
