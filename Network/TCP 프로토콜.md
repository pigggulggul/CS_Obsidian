#### TCP 프로토콜
연결을 지향하기 때문에 UDP보다는 안정적인 통신을 제공한다. 데이터를 안정적으로 순서대로 에러없이 전달 할 수 있게 해준다. 일반적으로 통신할 경우 TCP IPv4 Ethernet 프로토콜 3가지를 사용한다. TCP는 안전하게 전달할려고 여러 기능을 사용하기때문에 UDP보다 조금 느리지만 체감
#### TCP 프로토콜의 구조

|             |                       |                            |                  |     |
| ----------- | --------------------- | -------------------------- | ---------------- | --- |
| Byte Offset | 0                     | 1                          | 2                | 3   |
| 0           | Source Port           | -                          | Destination Port | -   |
| 4           | Sequence Number       | -                          | -                | -   |
| 8           | Acknowledgment Number | -                          | -                | -   |
| 12          | Offset/Reserved       | TCP Flags C E U A P R S F  | Window           | -   |
| 16          | Checksum              | -                          | Urgent Pointer   | -   |
| 20          | TCP Options ~         | (variable length,optional) | -                | -   |


**Offset**은 header의 길이.(똑같이 4로 나눔).
**Reserved** 예약된필드. 사용하지 않음.
**Window** 상대방한테 데이터 줄 때 허락을 받고 얼마만큼 더 보낼지 알려주는 것. 내 남아있는 TCP 버퍼를 알려주는 것
**TCP Options** 은 IP프로토콜 Option처럼 잘 안 붙고 붙어도 4바이트씩 붙는다 (총 10개까지. 일반적으로 20바이트지만 60바이트까지 늘어날 수 있음)

TCP 플래그 : U A P R S F 만 알면 된다. TCP는 통신하면서 상대방이랑 연결상태를 물어보는데 그 때 나타내는 값이다. 어떤 플래그를 세팅해서 보내는지에 따라서 물어보는건지, 데이터 보내도 되는지 대답, 연결종료인지, 연결 초기화인지, 데이터를 보내는건지, 급한데이턴지 등등 지정하는 값이 플래그이다.

#### TCP 플래그 종류
Urgent flag : 우선순위가 높은 데이터가 포함되어있다. U가 1이면 급한 데이터다. Urgent Pointer랑 세트이다.
**Ack flag** : 승인비트. 데이터 보내도 되는지 물어보는 것에 대해 응답해주는 플래그. 
Push flag : 밀어넣기비트. TCP버퍼가 일정 크기만큼 쌓여야 전송하는데 이거랑 상관없이 계속해서 데이터를 밀어넣겠다는 flag
**Reset flag** : 초기화 비트. 상대방과 연결되어있는 상태에서 데이터를 주고받을 때 문제가 발생하여 reset하자는 flag
**Sync flag** : 동기화비트.  상대방이랑 연결을 시작 할 때 무조건 사용하는 flag. Sync flag가 처음 보내진 후 부터 둘 사이의 연결이 동기화 됨
**Fin flag** : 종료비트. 연결을 끊을 때 사용하는 flag.
##### 플래그의 생김새 
.... ..0. .... U
.... ...0 .... A
.... .... 0... O
.... .... .0.. R
S
F

#### TCP를 이용한 통신과정
**연결 수립 과정** : 둘 사이의 연결을 수립하는 과정이 중요. TCP를 이용한 통신을 할 때 프로세스와 프로세스를 연결하기 위해 가장 먼저 수행되는 과정
1. 클라이언트가 서버에게 요청 패킷을 보냄. 서버가 클라이언트에 보내는경우는 거의 없다.
2. 서버가 클라이언트의 요청을 받아들이는 패킷을 보내고
3. 클라이언트는 이를 최종적으로 수락하는 패킷을 보낸다.
- 위의 3개의 과정을 3Way Handshake라고 부른다.

ex) 3Way Handshake의 예제
1. 클라이언트가 Eth|IPv4|TCP 패킷을 만들어서  웹 서버에 보낸다. 
	(Flag : SYN SEQ : 100, ACK : 0)
2. 서버가 요청을 받았으면 디캡슐화하여 내용을 확인한다.
3. 요청 왔다는걸 확인하고 답장하는 패킷을 만들어서 보낸다 
	(Flag : SYN+ACK S : 2000 A:101)
4. 클라이언트는 Sync와 Ack를 보고 요청을 수락하는 패킷을 보낸다 
	(Flag : ACK S:101 A:2001)

2-A 번호는 답장을 줄 때 받은 S 번호 +1를 한다. (101)
2-S 번호는 처음 보낼 때 자기만의 랜덤한 값을 생성한다. (2000)
3-A 번호는 받은 S번호 +1 한다. (2001)
3-S 번호는 답장을 보내는 것이므로 동기화가 되어 받은 A 번호가 된다 (101)

이렇게 수락이 되면 클라이언트가 먼저 요청을 보낸다.

**연결 수립 후 데이터 주고받는 과정** : 연결이 수립된 상태에서 데이터를 주고받을 때 SEQ, ACK번호를 이어가기 때문에 맨 마지막 클라이언트가 서버에게 패킷을 보내고 끝났는데 이 상태에서 클라이언트가 다시 데이터를 서버에게 보낸다.
1. 보낸 쪽에서 또 보낼 때는 SEQ번호와 ACK번호가 그대로다.
2. 받는 쪽에서 SEQ번호는 받은 ACK번호가 된다.
3. 받는 쪽에서 ACK번호는 받은 SEQ번호 + 데이터의 크기가 된다 (1이 아니다. 연결 수립 때는 데이터 페이로드가 없어서 1이였다)

ex) 
1. 캡슐화하여 데이터(100)를 담고 보낸다. 
	(Flag : PSH+ACK S:101 A:2001)
2. 서버가 클라이언트의 데이터를 받고 답장 패킷(500)을 보낸다 (ex: ㅁㅁ을 보내줘)
	(Flag : PSH+ACK S:2001 A:201)
3. 최종적으로 잘 받았다고 답장 패킷을 보낸다.
	(Flag : ACK S:201 A:2501)

#### TCP 상태전이도
데이터를 주고받으면서 TCP의 연결 상태가 변화한다.
CLOSED : 포트가 닫혀있는 상태 ( 클라 : active open 서버 : passive open  )
클라이언트가 포트를 능동적으로 열면서 SYN 패킷을 보내고 SYN_SENT 상태가 된다.
**LISTEN** : 4계층은 포트번호를 사용하고 프로그램이 실행중이면 특정 포트번호를 열어놓고 사용한다. 상대방의 요청을 듣고있는 상태.
SYN_SENT : 싱크 요청을 받으면 SYN_RCVD 상태가 된다 
SYN_RCVD : SYN,ACK 상태를 LISTEN으로 보낸다
**ESTABLISHED** : 연결이 서로 수립이 된 상태. 서버를 실행시켰으면 해당 서버의 포트번호가 LISTEN 상태인지 확인. 그 다음 클라이언트와 서로 연결을 하게 되면 이 상태가 된다. 그럼 통신 가능 상태가 됨

#### TCP/IP 연결에서 3way handshake 후
연결 후 파일을 다운로드 받으면 
##### Web 서버 상황
Server(프로세스)쪽에서는 소켓(파일)에 대고 RW(I/O)를 할 수 있는데 R하고 W를 각각 다른말로 부른다. R : Receive, W : Send. 그니까 서버 프로세스는 소켓에 대고 IO를 한다. HDD같은 메모리 장치 안에 File이 들어있다. A.bmp이 있을 때 파일 시스템에 의해 관리가 되어 데이터를 주거니 받거니 한다. 뭘 하든 서버에 메모리를 할당하게 되어있다. 파일이 1.4MB 일 때 메모리의 크기는 보통 1.4MB보다 작다. 메모리 사이즈가 64KB 일 때 64KB씩 끊어서 1.4MB를 읽어온다. 그럼 파일을 64KB씩 메모리에 끌어올려서 Read를 먼저 한 것이다. 그럼 이 프로세스는 소켓으로 TCP에 맞닿은 지점에 분해가 일어난다. 이 지점에서도 버퍼가 있다. 메모리의 버퍼를 1번, TCP의 버퍼가 2번 일 때,  버퍼1번의 메모리 64KB가 버퍼2번으로 카피가 된다.(Buffered I/O). TCP가 IP쪽으로 넘어 갈 때 Segment로 자른다. 직소퍼즐을 떠올리면 된다. 직소퍼즐 4개가 64KB면 버퍼1의 직소퍼즐 4개가 똑같이 복사돼서 버퍼2번에 저장된다. 이렇게 분해가 일어날 때 앞에 번호를 붙인다.  패킷이 택배박스라고 할 때 택배박스 안에 직소퍼즐 1번을 담는다. 패킷이 담기면 택배기사한테 맡겨서 NIC를 지나면 트럭(Frame)을 타고 인터넷을 통해 Client로 간다. 패킷은 논리적으로 end-point끝에서 끝으로 가지만 그게 frame화 돼서 갈 때는 frame이 생겼다 사라졌다한다. Client에 가는동안 트럭이 여러번 바껴서 간다.


![](https://i.imgur.com/VALrJr6.jpg)
##### Web 클라이언트 상황
PC 쪽에서도 NIC가 있고 서버랑 구조가 똑같다. 서버쪽에서도 버퍼가 있듯이 클라이언트 파일에도 버퍼가 있다. TCP도 똑같이 버퍼를 가지고 있다.
트럭(frame)이 왔을 때 트럭에서 택배를 꺼낼 때 IP를 만나면 박스가 뜯겨서 직소퍼즐(세그먼트)가 나온다. IP 수준에서 패킷의 분해가 일어나고 TCP단에서 세그먼트가 나온다. 나온 세그먼트는 TCP 버퍼에 저장이 된다. 이렇게 하나씩 오면서 버퍼에 세그먼트를 붙이는데 보통 세그먼트가 2개정도가 오면 잘 수신했다고 서버에 ACK에 번호를 붙여 보낸다. 서버 단에서는 2개정도를 보내고 기다리고 ACK를 받으면 그 때 3번을 보낸다. 이 때 wait를 하면서 속도지연이 발생하다 (TCP가 UDP보다 느린 이유). 클라이언트 단에서는 세그먼트를 2개까지 받았을 때 여유가 있다. 이 공간을 window size라고 말한다. (수신측에서 세그먼트가 날라왔을 때 조립해서 넣을 수 있는 공간). 그래서 ACK 3번을 보낼 때 window size도 같이 적어서 보낸다. 서버단에서 ACK를 받아서 3번을 보낼때 window size를 보고 세그먼트를 보낼 여유공간이 없으면 보내지 않는다. 전송을 할 때 수신측의 window size > mss(maximum segment size)면 보낸다. 크지 않으면 보내지 않고 wait가 걸린다. TCP에는 세그먼트들이 계속 쌓이는데 TCP 버퍼의 있는 세그먼트를 File I/O Buffer로 보내야한다. 프로세스 입장에서도 소켓에 대해 RW를 하는데 Receive의 속돌들 따져야한다. TCP Buffer에서 File I/O Buffer로 올리는 Read 속도가 Network 수신 속도 (세그먼트를 TCP Buffer로 옮기는 속도)보다 빨라야한다. Network 수신속독